/*! \file timer.c
 *

 *  \copyright (C) Copyright 2015 University of Antwerp and others (http://oss-7.cosys.be)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * \author maarten.weyn@uantwerpen.be
 * \author glenn.ergeerts@uantwerpen.be
 */
#include "timer.h"

#include "../hal/timer.h"
#include "log.h"

#define LOG_FWK_ENABLED

// turn on/off the debug prints
#ifdef LOG_FWK_ENABLED
#define DPRINT(...) log_print_stack_string(LOG_FWK, __VA_ARGS__)
#else
#define DPRINT(...)  
#endif


void timer_init()
{
    hal_timer_init();

    queue_init(&event_queue, (uint8_t*)&event_array, sizeof(event_array), sizeof(timer_event));
    started = false;
}

bool timer_insert_value_in_queue(timer_event* event)
{
	uint16_t current_timer = hal_timer_getvalue();

        DPRINT("timer_insert current_time %d", current_timer);
        DPRINT(" - next %d queue len %d", event->next_event, event_queue.length);

    // TODO: substract time already gone
	uint8_t position = 0;
	uint16_t next_event =  event->next_event;
	event->next_event = current_timer + event->next_event;

	while (position < event_queue.length)
	{
<<<<<<< HEAD
		timer_event *temp_event = (timer_event*) queue_read_value(&event_queue, position);
		#ifdef LOG_FWK_ENABLED
		log_print_stack_string(LOG_FWK, " - temp_event: %d - current_timer %d (%d)", temp_event->next_event, current_timer, temp_event->next_event - current_timer);
		#endif
		if ((temp_event->next_event - current_timer)  > next_event)
		{
			#ifdef LOG_FWK_ENABLED
			log_print_stack_string(LOG_FWK, " - next-event-current_timer > next_event");
			log_print_stack_string(LOG_FWK, " - %d > %d", temp_event->next_event - current_timer, next_event);
			#endif
=======

        DPRINT(" - position  %d queue len %d", position, event_queue.length);
		timer_event *temp_event = (timer_event*) queue_read_value(&event_queue, position, sizeof(timer_event));

        DPRINT(" - tempevent  next_event %d event %p", temp_event->next_event, temp_event->f);
        DPRINT(" - tempevent  ne - ct %d",  temp_event->next_event - current_timer);

        if ((temp_event->next_event - current_timer)  > next_event)
		{
        	DPRINT(" - ne-ct > ne");
>>>>>>> master
			if (position == 0)
			{
				DPRINT(" - position == 0");
				hal_timer_disable_interrupt();
				started = false;
			}
			queue_insert_value(&event_queue, (void*) event, position);
			position = 0;
			break;
		}
		position++;
	}

	if (position == event_queue.length)
	{
		#ifdef LOG_FWK_ENABLED
		log_print_stack_string(LOG_FWK, " - position == event_queue.length");
		#endif
		if (!queue_push_value(&event_queue, (void*) event))
		{
			#ifdef LOG_FWK_ENABLED
			log_print_stack_string(LOG_FWK, " - Cannot add timmer at the end");
			#endif

			return false;
		}
		#ifdef LOG_FWK_ENABLED
		else {

			log_print_stack_string(LOG_FWK, " - Timer added at the end");
		}
		#endif
	}

	#ifdef LOG_FWK_ENABLED
	position = 0;
	for (;position<event_queue.length; position++)
	{
<<<<<<< HEAD
		timer_event *temp_event = (timer_event*) queue_read_value(&event_queue, position);
		log_print_stack_string(LOG_FWK, "Queue: %d.%d", temp_event->next_event/1000, temp_event->next_event%1000);
=======
		timer_event *temp_event = (timer_event*) queue_read_value(&event_queue, position, sizeof(timer_event));
		DPRINT("Queue: %d", temp_event->next_event);
>>>>>>> master
	}
	DPRINT("timer_insert E - Timer current value: %d",  hal_timer_getvalue());
	#endif
	/*
	// code when timer was up instead of continous
    int16_t sum_next_event = - hal_timer_getvalue();

    while (position < event_queue.length)
    {
        timer_event *temp_event = (timer_event*) queue_read_value(&event_queue, position, sizeof(timer_event));
        if (event->next_event > sum_next_event + temp_event->next_event)
        {
            sum_next_event += temp_event->next_event;
        } else {
            uint16_t elapsed = 0;
            if (position == 0)
            {
                elapsed = hal_timer_getvalue();
                hal_timer_disable_interrupt();
                started = false;
            } else {c
                event->next_event -= sum_next_event;
            }

            queue_insert_value(&event_queue, (void*) event, position, sizeof(timer_event));
            temp_event = (timer_event*) queue_read_value(&event_queue, position+1, sizeof(timer_event));

            temp_event->next_event -= (event->next_event + elapsed);
            return true;
        }
        position++;
    }

    if (position == event_queue.length)
    {
        if (started) event->next_event -= sum_next_event;
        return queue_push_value(&event_queue, (void*) event, sizeof(timer_event));
    }
    */

    return true;
}

bool timer_add_event(timer_event* event)
{

    DPRINT("Add event: current timer: %d.", hal_timer_getvalue());

    if (event->next_event == 0)
    {
        event->f();
        return true;
    }

    timer_event new_event;
    new_event.f = event->f;
    new_event.next_event = event->next_event;


    DPRINT(" - new event : %d %p", new_event.next_event, new_event.f);

    if (timer_insert_value_in_queue(&new_event))
    {
        if (!started)
        {
            hal_timer_enable_interrupt();
            started = true;
            hal_timer_setvalue(new_event.next_event);
        }
        uint16_t diff = hal_timer_getvalue() - new_event.next_event;
        if (diff < 1000)
		{
                    DPRINT("timer_add_event M timer overrun : %d", hal_timer_getvalue());
                    DPRINT("timer_add_event M: %d", new_event.next_event);
                    timer_completed();
		}
    } else {
        DPRINT("Cannot add event, queue is full");
        return false;
    }

    DPRINT("timer_add_event timer E : %d", hal_timer_getvalue());

    return true;
}

void timer_completed()
{

    DPRINT("Timer Completed: cti: %d", hal_timer_getvalue());

    timer_event* event = (timer_event*) queue_pop_value(&event_queue);

    DPRINT(" - event  next_event %d event %p", event->next_event, event->f);
    DPRINT(" - event_queue lenght   %d ", event_queue.length);

    bool directly_fire_new_event = false;

    if (event_queue.length == 0)
    {
        hal_timer_disable_interrupt();
        started = false;
    } else {
    	DPRINT(" - next_event  next_event %d event %p", ((timer_event*) event_queue.front)->next_event, ((timer_event*) event_queue.front)->f);

        hal_timer_setvalue(((timer_event*) event_queue.front)->next_event);
        uint16_t diff = hal_timer_getvalue() - ((timer_event*) event_queue.front)->next_event;
        DPRINT(" - diff   %d ", diff);

        if (diff < 1000)
        {
            directly_fire_new_event = true;
        }
    }

    event->f();

    if (directly_fire_new_event)
    {
    	timer_completed();
    }
}

uint16_t timer_get_counter_value()
{
    return hal_timer_getvalue();
}

volatile bool waiting;

void timer_wait_done(void)
{
    waiting = false;
}

timer_event timer_wait = { .next_event = 0, .f = timer_wait_done };

void timer_wait_ms(uint16_t ms)
{
    /*
	waiting = true;
    timer_wait.next_event = ms;
    timer_add_event( &timer_wait );
    while(waiting);
    */
    int i;
    for( i=0 ; i<ms ; i++ )
    {
            volatile uint32_t n = 32000;
            while(n--);
    }
}


void benchmarking_timer_init()
{
	hal_benchmarking_timer_init();
}

uint32_t benchmarking_timer_getvalue()
{
    return hal_benchmarking_timer_getvalue();
}
void benchmarking_timer_start()
{
	hal_benchmarking_timer_start();
}

void benchmarking_timer_stop()
{
	hal_benchmarking_timer_stop();
}
