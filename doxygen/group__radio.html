<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>OSS-7: Open Source Stack for DASH7 Alliance Protocol: Radio</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OSS-7: Open Source Stack for DASH7 Alliance Protocol
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__radio.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Radio<div class="ingroups"><a class="el" href="group___h_a_l.html">Hardware Abstraction Layer API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The interface specification for accessing the radio interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphy__channel__header__t.html">phy_channel_header_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structchannel__id__t.html">channel_id_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel id used to identify the spectrum settings  <a href="structchannel__id__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__rx__cfg__t.html">hw_rx_cfg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'RX Configuration' for the radio.  <a href="structhw__rx__cfg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhw__tx__cfg__t.html">hw_tx_cfg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'TX Configuration' to use when sending a packet.  <a href="structhw__tx__cfg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct____attribute____.html">__attribute__</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The metadata attached to a received packet.  <a href="struct____attribute____.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac55228f9ea3c257706e9316da32ce87e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gac55228f9ea3c257706e9316da32ce87e">HW_RSSI_INVALID</a>&#160;&#160;&#160;0x7FFF</td></tr>
<tr class="separator:gac55228f9ea3c257706e9316da32ce87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea11be8a05e4a87040bd5f0c10c911c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga1ea11be8a05e4a87040bd5f0c10c911c">HW_PACKET_BUF_SIZE</a>(length)&#160;&#160;&#160;(sizeof(hw_radio_packet_t) + length)</td></tr>
<tr class="memdesc:ga1ea11be8a05e4a87040bd5f0c10c911c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience MACRO that calculates the minimum size of a buffer large enough to hold a single hw_radio_packet_t of the specified length.  <a href="#ga1ea11be8a05e4a87040bd5f0c10c911c">More...</a><br /></td></tr>
<tr class="separator:ga1ea11be8a05e4a87040bd5f0c10c911c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaebbaa832b63f7d77fddaaf7098ad69f0"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gaebbaa832b63f7d77fddaaf7098ad69f0">syncword_class_t</a></td></tr>
<tr class="memdesc:gaebbaa832b63f7d77fddaaf7098ad69f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the 'syncword class'  <a href="#gaebbaa832b63f7d77fddaaf7098ad69f0">More...</a><br /></td></tr>
<tr class="separator:gaebbaa832b63f7d77fddaaf7098ad69f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02dafdf72e21d57e731354cb6192583c"><td class="memItemLeft" align="right" valign="top">typedef int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga02dafdf72e21d57e731354cb6192583c">eirp_t</a></td></tr>
<tr class="memdesc:ga02dafdf72e21d57e731354cb6192583c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the 'eirp' used to transmit packets  <a href="#ga02dafdf72e21d57e731354cb6192583c">More...</a><br /></td></tr>
<tr class="separator:ga02dafdf72e21d57e731354cb6192583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2efbab7ef580464c95416fdbe9cd2c"><td class="memItemLeft" align="right" valign="top">typedef hw_radio_packet_t *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gaed2efbab7ef580464c95416fdbe9cd2c">alloc_packet_callback_t</a>) (uint8_t length)</td></tr>
<tr class="memdesc:gaed2efbab7ef580464c95416fdbe9cd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the 'new_packet' callback function.  <a href="#gaed2efbab7ef580464c95416fdbe9cd2c">More...</a><br /></td></tr>
<tr class="separator:gaed2efbab7ef580464c95416fdbe9cd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga822e576af2256b03278c9945b8d6aacf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga822e576af2256b03278c9945b8d6aacf">release_packet_callback_t</a>) (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>)</td></tr>
<tr class="memdesc:ga822e576af2256b03278c9945b8d6aacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the callback used by the PHY driver to 'release' control of a previously allocated packet buffer.  <a href="#ga822e576af2256b03278c9945b8d6aacf">More...</a><br /></td></tr>
<tr class="separator:ga822e576af2256b03278c9945b8d6aacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf118d5fc80084fae379668fd97f9719b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gaf118d5fc80084fae379668fd97f9719b">rx_packet_callback_t</a>) (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>)</td></tr>
<tr class="memdesc:gaf118d5fc80084fae379668fd97f9719b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the rx callback function.  <a href="#gaf118d5fc80084fae379668fd97f9719b">More...</a><br /></td></tr>
<tr class="separator:gaf118d5fc80084fae379668fd97f9719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f2e4e8140549c0ac3abcf7fefb9e77"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gac2f2e4e8140549c0ac3abcf7fefb9e77">tx_packet_callback_t</a>) (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>)</td></tr>
<tr class="memdesc:gac2f2e4e8140549c0ac3abcf7fefb9e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the tx callback function.  <a href="#gac2f2e4e8140549c0ac3abcf7fefb9e77">More...</a><br /></td></tr>
<tr class="separator:gac2f2e4e8140549c0ac3abcf7fefb9e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba48debc5245ec6150ac6eb1db19766"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga0ba48debc5245ec6150ac6eb1db19766">rssi_valid_callback_t</a>) (int16_t cur_rssi)</td></tr>
<tr class="memdesc:ga0ba48debc5245ec6150ac6eb1db19766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the rssi_valid callback function.  <a href="#ga0ba48debc5245ec6150ac6eb1db19766">More...</a><br /></td></tr>
<tr class="separator:ga0ba48debc5245ec6150ac6eb1db19766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga322511bb0837a24ade5987e2a5d8cb4d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga322511bb0837a24ade5987e2a5d8cb4d">phy_channel_band_t</a> { <a class="el" href="group__radio.html#gga322511bb0837a24ade5987e2a5d8cb4da115d4b1da052691249becafde483644c">PHY_BAND_433</a> = 0x02, 
<a class="el" href="group__radio.html#gga322511bb0837a24ade5987e2a5d8cb4da49f14703507f58b1066e8b26b319645f">PHY_BAND_868</a> = 0x03, 
<a class="el" href="group__radio.html#gga322511bb0837a24ade5987e2a5d8cb4da7d3fb444935bedb54206db2bc3c0f173">PHY_BAND_915</a> = 0x04
 }</td></tr>
<tr class="separator:ga322511bb0837a24ade5987e2a5d8cb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5237948055f92b747764c14ae1afc6c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga5237948055f92b747764c14ae1afc6c5">phy_channel_class_t</a> { <a class="el" href="group__radio.html#gga5237948055f92b747764c14ae1afc6c5aa92be053cf4f008cf0be7db6fae83aa3">PHY_CLASS_LO_RATE</a> = 0x00, 
<a class="el" href="group__radio.html#gga5237948055f92b747764c14ae1afc6c5a8d8dd629344f3aa20914a0ef1f900dee">PHY_CLASS_NORMAL_RATE</a> = 0x02, 
<a class="el" href="group__radio.html#gga5237948055f92b747764c14ae1afc6c5a259a16f66bba259924de2524c2d3818e">PHY_CLASS_HI_RATE</a> = 0x03
 }</td></tr>
<tr class="separator:ga5237948055f92b747764c14ae1afc6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11cd6e8bdbe5df40f17f84c35a0da08b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga11cd6e8bdbe5df40f17f84c35a0da08b">phy_coding_t</a> { <a class="el" href="group__radio.html#gga11cd6e8bdbe5df40f17f84c35a0da08baee4e6d4d37cd427b731d955ca40197d5">PHY_CODING_PN9</a> = 0x00, 
<a class="el" href="group__radio.html#gga11cd6e8bdbe5df40f17f84c35a0da08ba7c73dfd2514dc4bc5b1f0aa788952ee8">PHY_CODING_FEC_PN9</a> = 0x02
 }</td></tr>
<tr class="separator:ga11cd6e8bdbe5df40f17f84c35a0da08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290fd131fe635641e94a85f5989db8bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga290fd131fe635641e94a85f5989db8bf">phy_syncword_class_t</a> { <a class="el" href="group__radio.html#gga290fd131fe635641e94a85f5989db8bfac1d0339ffdfedce2e5c8ed412231dfd4">PHY_SYNCWORD_CLASS0</a> = 0x00, 
<a class="el" href="group__radio.html#gga290fd131fe635641e94a85f5989db8bfaea7716a0020f786fce3d527816aa0d87">PHY_SYNCWORD_CLASS1</a> = 0x01
 }</td></tr>
<tr class="separator:ga290fd131fe635641e94a85f5989db8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacac7e6e2d75dd8527eaf4b636ac47ebb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gacac7e6e2d75dd8527eaf4b636ac47ebb">hw_crc_t</a> { <a class="el" href="group__radio.html#ggacac7e6e2d75dd8527eaf4b636ac47ebba2304cc75318ef9009908fe27d875413b">HW_CRC_VALID</a> = 0, 
<a class="el" href="group__radio.html#ggacac7e6e2d75dd8527eaf4b636ac47ebba54b700f89a790e78293c1bdf914a7e4e">HW_CRC_INVALID</a> = 1, 
<a class="el" href="group__radio.html#ggacac7e6e2d75dd8527eaf4b636ac47ebba6be141209743a169478ceaac77dac2da">HW_CRC_UNAVAILABLE</a> = 2
 }</td></tr>
<tr class="memdesc:gacac7e6e2d75dd8527eaf4b636ac47ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the result of a 'hardware' crc check.  <a href="group__radio.html#gacac7e6e2d75dd8527eaf4b636ac47ebb">More...</a><br /></td></tr>
<tr class="separator:gacac7e6e2d75dd8527eaf4b636ac47ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaefab8edede99183d3c557c0d37d3fb93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gaefab8edede99183d3c557c0d37d3fb93">hw_radio_init</a> (<a class="el" href="group__radio.html#gaed2efbab7ef580464c95416fdbe9cd2c">alloc_packet_callback_t</a> p_alloc, <a class="el" href="group__radio.html#ga822e576af2256b03278c9945b8d6aacf">release_packet_callback_t</a> p_free)</td></tr>
<tr class="memdesc:gaefab8edede99183d3c557c0d37d3fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the radio driver.  <a href="#gaefab8edede99183d3c557c0d37d3fb93">More...</a><br /></td></tr>
<tr class="separator:gaefab8edede99183d3c557c0d37d3fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a7a12a95592bbb1a55532e5ddd9e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gac4a7a12a95592bbb1a55532e5ddd9e6f">hw_radio_set_idle</a> ()</td></tr>
<tr class="memdesc:gac4a7a12a95592bbb1a55532e5ddd9e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio in the IDLE mode.  <a href="#gac4a7a12a95592bbb1a55532e5ddd9e6f">More...</a><br /></td></tr>
<tr class="separator:gac4a7a12a95592bbb1a55532e5ddd9e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343b42352c72528dd71cc8b09a0f820b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga343b42352c72528dd71cc8b09a0f820b">hw_radio_is_idle</a> ()</td></tr>
<tr class="memdesc:ga343b42352c72528dd71cc8b09a0f820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the radio is in IDLE mode.  <a href="#ga343b42352c72528dd71cc8b09a0f820b">More...</a><br /></td></tr>
<tr class="separator:ga343b42352c72528dd71cc8b09a0f820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb8ffcdd89455429d4d13caf08fb661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gaeeb8ffcdd89455429d4d13caf08fb661">hw_radio_set_rx</a> (<a class="el" href="structhw__rx__cfg__t.html">hw_rx_cfg_t</a> const *rx_cfg, <a class="el" href="group__radio.html#gaf118d5fc80084fae379668fd97f9719b">rx_packet_callback_t</a> rx_callback, <a class="el" href="group__radio.html#ga0ba48debc5245ec6150ac6eb1db19766">rssi_valid_callback_t</a> rssi_callback)</td></tr>
<tr class="memdesc:gaeeb8ffcdd89455429d4d13caf08fb661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio in RX mode.  <a href="#gaeeb8ffcdd89455429d4d13caf08fb661">More...</a><br /></td></tr>
<tr class="separator:gaeeb8ffcdd89455429d4d13caf08fb661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbc4103ec8a4f6a45edeabffe58990d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga6bbc4103ec8a4f6a45edeabffe58990d">hw_radio_is_rx</a> ()</td></tr>
<tr class="memdesc:ga6bbc4103ec8a4f6a45edeabffe58990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the radio is in RX mode.  <a href="#ga6bbc4103ec8a4f6a45edeabffe58990d">More...</a><br /></td></tr>
<tr class="separator:ga6bbc4103ec8a4f6a45edeabffe58990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7292dedeeb8229173201c2987811fb8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga7292dedeeb8229173201c2987811fb8f">hw_radio_send_packet</a> (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>, <a class="el" href="group__radio.html#gac2f2e4e8140549c0ac3abcf7fefb9e77">tx_packet_callback_t</a> tx_callback)</td></tr>
<tr class="memdesc:ga7292dedeeb8229173201c2987811fb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a packet transmission over the air with the specified TX settings.  <a href="#ga7292dedeeb8229173201c2987811fb8f">More...</a><br /></td></tr>
<tr class="separator:ga7292dedeeb8229173201c2987811fb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4c71396001bf829c2527e944637a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gabc4c71396001bf829c2527e944637a07">hw_radio_tx_busy</a> ()</td></tr>
<tr class="memdesc:gabc4c71396001bf829c2527e944637a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the radio is currently transmitting a packet.  <a href="#gabc4c71396001bf829c2527e944637a07">More...</a><br /></td></tr>
<tr class="separator:gabc4c71396001bf829c2527e944637a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb55024f4373099a0e06dc8f153c47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#gaedcb55024f4373099a0e06dc8f153c47">hw_radio_rx_busy</a> ()</td></tr>
<tr class="memdesc:gaedcb55024f4373099a0e06dc8f153c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the radio is currently receiving a packet.  <a href="#gaedcb55024f4373099a0e06dc8f153c47">More...</a><br /></td></tr>
<tr class="separator:gaedcb55024f4373099a0e06dc8f153c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465cfc9c5af38c3e38fffdf4a65f9e11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga465cfc9c5af38c3e38fffdf4a65f9e11">hw_radio_rssi_valid</a> ()</td></tr>
<tr class="memdesc:ga465cfc9c5af38c3e38fffdf4a65f9e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the RSSI value measured by the PHY driver is valid or not.  <a href="#ga465cfc9c5af38c3e38fffdf4a65f9e11">More...</a><br /></td></tr>
<tr class="separator:ga465cfc9c5af38c3e38fffdf4a65f9e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ffbd2f8c0aec2f95fbdb365c39d682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html#ga43ffbd2f8c0aec2f95fbdb365c39d682">hw_radio_get_rssi</a> ()</td></tr>
<tr class="memdesc:ga43ffbd2f8c0aec2f95fbdb365c39d682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the current RSSI on the channel.  <a href="#ga43ffbd2f8c0aec2f95fbdb365c39d682">More...</a><br /></td></tr>
<tr class="separator:ga43ffbd2f8c0aec2f95fbdb365c39d682"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The interface specification for accessing the radio interface. </p>
<dl class="section author"><dt>Author</dt><dd>Daniel van den Akker </dd>
<dd>
Glenn Ergeerts </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga1ea11be8a05e4a87040bd5f0c10c911c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_PACKET_BUF_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">length</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(hw_radio_packet_t) + length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience MACRO that calculates the minimum size of a buffer large enough to hold a single hw_radio_packet_t of the specified length. </p>
<p>This functionality is defined as a MACRO rather than a static inline function to allow it to be used for compile-time calculations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the packet to be allocated (max 255) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac55228f9ea3c257706e9316da32ce87e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_RSSI_INVALID&#160;&#160;&#160;0x7FFF</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaed2efbab7ef580464c95416fdbe9cd2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef hw_radio_packet_t*(* alloc_packet_callback_t) (uint8_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type definition for the 'new_packet' callback function. </p>
<p>The new_packet_callback_t function is called by the PHY driver each time a (new) buffer is needed to store a packet. This function is supplied with the <em>length</em> of the packet to be stored and is expected to return a pointer to a 'hw_radio_packet_t' that is sufficiently large to contain a packet that is at least length bytes long. If no sufficiently large buffer can be allocated, this function MUST return NULL (0x0).</p>
<p>It should be noted that this function is typically called while the packet is being received and as a result it is imperative that this function does at little processing as possible. Also, this function may be called both from a 'thread' and from an interrupt context. Implementors are advised to use atomic sections (where needed) to protect against concurrency issues.</p>
<p>Once a packet has been allocated, it remains under the control of the PHY driver until it is `released' by a call to either the release_packet_callback or the rx_packet_callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the packet for which a buffer must be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hw_radio_packet_t* The allocated packet buffer. The buffer MUST be large enough for the data field to contain at least length bytes. If no sufficiently large buffer can be allocated, 0x0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02dafdf72e21d57e731354cb6192583c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int8_t <a class="el" href="group__radio.html#ga02dafdf72e21d57e731354cb6192583c">eirp_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of the 'eirp' used to transmit packets </p>

</div>
</div>
<a class="anchor" id="ga822e576af2256b03278c9945b8d6aacf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* release_packet_callback_t) (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>definition of the callback used by the PHY driver to 'release' control of a previously allocated packet buffer. </p>
<p>This callback is called by the PHY driver when it determines that a previously allocated packet buffer is no longer needed (for instance because the RX was interrupted). If the packet WAS received correctly, control of the buffer is released through a call to rx_callback_packet_t.</p>
<p>As with new_packet_callback_t, this function is called from an interrupt context during time-critical PHY layer processing. As a result, this function should do as little processing as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A pointer to the hw_radio_packet to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ba48debc5245ec6150ac6eb1db19766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rssi_valid_callback_t) (int16_t cur_rssi)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type definition for the rssi_valid callback function. </p>
<p>The rssi_valid callback is called by the PHY driver every time the RSSI measurements of the radio become valid after the radio is put in RX mode (see hw_radio_set_rx).</p>
<p>A callback to the rssi_valid function is not only triggered by a call to hw_radio_set_rx, but also but also by a call to hw_radio_send_packet. In that case, rssi_valid is called when the radio enters RX mode after the packet has been transmitted. (Unless of course the radio was put in IDLE mode during tx).</p>
<p>This function is called from an interrupt context and should therefore do as little processing as possible. </p>

</div>
</div>
<a class="anchor" id="gaf118d5fc80084fae379668fd97f9719b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rx_packet_callback_t) (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type definition for the rx callback function. </p>
<p>The rx_packet_callback_t function is called by the PHY driver every time a new packet is received. This function is supplied with a pointer the hw_radio_packet containing the received packet.</p>
<p>It should be noted that the `packet' pointer supplied to this callback function is <em>ALWAYS</em> a pointer that was obtained through a call to the new_packet_callback (new_packet_callback_t) function. By calling this function, the PHY driver explicitly releases control of the previously allocated buffer back to the radio stack. This means that, from the perspective of the radio driver, calling rx_packet_callback_t has the same effect as calling release_packet_callback_t.</p>
<p>As with new_packet_callback_t, this function is called from an interrupt context. While this function is being executed, no other interrupts can fire and no other packets can be received. As a result, this function should do as little processing as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A pointer to the received packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebbaa832b63f7d77fddaaf7098ad69f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group__radio.html#gaebbaa832b63f7d77fddaaf7098ad69f0">syncword_class_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of the 'syncword class' </p>

</div>
</div>
<a class="anchor" id="gac2f2e4e8140549c0ac3abcf7fefb9e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tx_packet_callback_t) (hw_radio_packet_t *<a class="el" href="structpacket.html">packet</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type definition for the tx callback function. </p>
<p>The tx_packet_callback_t function is called by the PHY driver upon completion of a packet transmission. This function is supplied with a pointer to the transmitted packet (the packet supplied to the hw_radio_send_packet function)</p>
<p>As with new_packet_callback_t, this function is called from an interrupt context and should therefore do as little processing as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A pointer to the transmitted packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gacac7e6e2d75dd8527eaf4b636ac47ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__radio.html#gacac7e6e2d75dd8527eaf4b636ac47ebb">hw_crc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for the result of a 'hardware' crc check. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacac7e6e2d75dd8527eaf4b636ac47ebba2304cc75318ef9009908fe27d875413b"></a>HW_CRC_VALID&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacac7e6e2d75dd8527eaf4b636ac47ebba54b700f89a790e78293c1bdf914a7e4e"></a>HW_CRC_INVALID&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacac7e6e2d75dd8527eaf4b636ac47ebba6be141209743a169478ceaac77dac2da"></a>HW_CRC_UNAVAILABLE&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga322511bb0837a24ade5987e2a5d8cb4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__radio.html#ga322511bb0837a24ade5987e2a5d8cb4d">phy_channel_band_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga322511bb0837a24ade5987e2a5d8cb4da115d4b1da052691249becafde483644c"></a>PHY_BAND_433&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga322511bb0837a24ade5987e2a5d8cb4da49f14703507f58b1066e8b26b319645f"></a>PHY_BAND_868&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga322511bb0837a24ade5987e2a5d8cb4da7d3fb444935bedb54206db2bc3c0f173"></a>PHY_BAND_915&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5237948055f92b747764c14ae1afc6c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__radio.html#ga5237948055f92b747764c14ae1afc6c5">phy_channel_class_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5237948055f92b747764c14ae1afc6c5aa92be053cf4f008cf0be7db6fae83aa3"></a>PHY_CLASS_LO_RATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5237948055f92b747764c14ae1afc6c5a8d8dd629344f3aa20914a0ef1f900dee"></a>PHY_CLASS_NORMAL_RATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga5237948055f92b747764c14ae1afc6c5a259a16f66bba259924de2524c2d3818e"></a>PHY_CLASS_HI_RATE&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga11cd6e8bdbe5df40f17f84c35a0da08b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__radio.html#ga11cd6e8bdbe5df40f17f84c35a0da08b">phy_coding_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga11cd6e8bdbe5df40f17f84c35a0da08baee4e6d4d37cd427b731d955ca40197d5"></a>PHY_CODING_PN9&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga11cd6e8bdbe5df40f17f84c35a0da08ba7c73dfd2514dc4bc5b1f0aa788952ee8"></a>PHY_CODING_FEC_PN9&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga290fd131fe635641e94a85f5989db8bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__radio.html#ga290fd131fe635641e94a85f5989db8bf">phy_syncword_class_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga290fd131fe635641e94a85f5989db8bfac1d0339ffdfedce2e5c8ed412231dfd4"></a>PHY_SYNCWORD_CLASS0&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga290fd131fe635641e94a85f5989db8bfaea7716a0020f786fce3d527816aa0d87"></a>PHY_SYNCWORD_CLASS1&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga43ffbd2f8c0aec2f95fbdb365c39d682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> int16_t hw_radio_get_rssi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the current RSSI on the channel. </p>
<p>If the RSSI is not valid (hw_radio_rssi_valied() returns false), the special value 'HW_RSSI_INVALID' is returned. Otherwise the current RSSI is returned. The RSSI is measured in dBm and must be rounded to the nearest 16-bit signed integer value.</p>
<p>If HW_RSSI_INVALID is returned, the caller shoud ensure that the radio is actually in RX mode and, if so, either schedule the RSSI to be read at a later time or wait for the rssi_valid callback to be invoked.</p>
<p>Measuring the RSSI is done using the 'current' RX settings of the radio and does NOT interrupt any receive operation currently in progress.</p>
<p>Reading the RSSI for a different RX configuration can be done by:</p><ol type="1">
<li>Setting the required settings by calling hw_radio_set_rx</li>
<li>Waiting for the rssi_valid callback to be invoked. </li>
</ol>

</div>
</div>
<a class="anchor" id="gaefab8edede99183d3c557c0d37d3fb93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> hw_radio_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__radio.html#gaed2efbab7ef580464c95416fdbe9cd2c">alloc_packet_callback_t</a>&#160;</td>
          <td class="paramname"><em>p_alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__radio.html#ga822e576af2256b03278c9945b8d6aacf">release_packet_callback_t</a>&#160;</td>
          <td class="paramname"><em>p_free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the radio driver. </p>
<p>After initialisation, the radio is in IDLE state. The RX must be explicitly enabled by a call to hw_radio_set_rx(...) before any packets can be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_alloc</td><td>The new_packet_callback_t function to call whenever a buffer is needed to store a new packet. Please note that this function is called from an <em>interrupt</em> context and therefore can only do minimal processing.</td></tr>
    <tr><td class="paramname">p_free</td><td>The release_packet_callback_t function to call whenever an allocated buffer is not needed any more. (A buffer can also be release by a call to p_callback) Please note that this function is called from an <em>interrupt</em> context and therefore can only do minimal processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error_t SUCCESS if the radio driver was initialised successfully EINVAL if any of the callback functions is 0x0 EALREADY if the radio driver was already initialised FAIL if the radio driver could not be initialised </dd></dl>

</div>
</div>
<a class="anchor" id="ga343b42352c72528dd71cc8b09a0f820b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool hw_radio_is_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether or not the radio is in IDLE mode. </p>
<p>Please note that if <a class="el" href="group__radio.html#gac4a7a12a95592bbb1a55532e5ddd9e6f" title="Set the radio in the IDLE mode. ">hw_radio_set_idle()</a> was called while a transmission was still in progress, <a class="el" href="group__radio.html#ga343b42352c72528dd71cc8b09a0f820b" title="Check whether or not the radio is in IDLE mode. ">hw_radio_is_idle()</a> will return TRUE even if the transmission is still in progress.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the radio is in idle mode, false if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bbc4103ec8a4f6a45edeabffe58990d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool hw_radio_is_rx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether or not the radio is in RX mode. </p>
<p>Please note that if <a class="el" href="group__radio.html#gaeeb8ffcdd89455429d4d13caf08fb661" title="Set the radio in RX mode. ">hw_radio_set_rx()</a> was called while a transmission was still in progress, <a class="el" href="group__radio.html#ga6bbc4103ec8a4f6a45edeabffe58990d" title="Check whether or not the radio is in RX mode. ">hw_radio_is_rx()</a> will return TRUE even if the transmission is still in progress.</p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the radio is in RX mode, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga465cfc9c5af38c3e38fffdf4a65f9e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hw_radio_rssi_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the RSSI value measured by the PHY driver is valid or not. </p>
<p>The RSSI will only be valid if the radio has been initialised and has been in RX mode long enough for the RSSI to become valid (this is signalled by a callback to the rssi_valid_callback_t function)</p>
<p>In general the following rule applies:</p><ul>
<li><a class="el" href="group__radio.html#ga465cfc9c5af38c3e38fffdf4a65f9e11" title="Check whether the RSSI value measured by the PHY driver is valid or not. ">hw_radio_rssi_valid()</a> == (<a class="el" href="group__radio.html#ga43ffbd2f8c0aec2f95fbdb365c39d682" title="Measure the current RSSI on the channel. ">hw_radio_get_rssi()</a> == HW_RSSI_INVALID) </li>
</ul>

</div>
</div>
<a class="anchor" id="gaedcb55024f4373099a0e06dc8f153c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool hw_radio_rx_busy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether or not the radio is currently receiving a packet. </p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the radio is currently receiving a packet, false if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7292dedeeb8229173201c2987811fb8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> hw_radio_send_packet </td>
          <td>(</td>
          <td class="paramtype">hw_radio_packet_t *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__radio.html#gac2f2e4e8140549c0ac3abcf7fefb9e77">tx_packet_callback_t</a>&#160;</td>
          <td class="paramname"><em>tx_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a packet transmission over the air with the specified TX settings. </p>
<p>This function sends the packet pointed to by the packet parameter over the air. Packets are always transmitted using the tx_cfg settings in the tx_meta field of the supplied packet. If these settings are not valid, EINVAL is returned and the packet is not transmitted. Moreover the 'length' field of the packet must also be properly configured. More specifically, the radio will send the first 'length' bytes of the packet's 'data' buffer over the air. It is the responsibility of the caller to ensure that the 'length' of the packet has been properly configured.</p>
<p>Packet transmission is always done <em>asynchronously</em>, that is: a packet transmission is initiated by a call to this function, but is not completed until the tx_packet_callback_t function supplied to the hw_radio_init function is invoked by the radio driver. If this function is 0x0, no callback will occur. In that case the user must check that the transmission has finished by querying the hw_radio_tx_busy function. The packet buffer supplied to this function <em>MUST</em> remain available until the transmission has been completed. It should be noted that the tx_callback function will ONLY be called if this function pointer != 0x0 and the hw_radio_send_packet function returns SUCCESS.</p>
<p>If a transmission is initiated while the radio is in IDLE mode, the radio switches directly from IDLE mode to TX mode to transmit the packet. After the packet has been sent, it switches back to IDLE mode (unless <a class="el" href="group__radio.html#gaeeb8ffcdd89455429d4d13caf08fb661" title="Set the radio in RX mode. ">hw_radio_set_rx()</a> is called while the TX is in progress).</p>
<p>If a transmission is initiated while the radio is in RX mode, the radio switches immediately to TX mode to transmit the packet. If a packet reception is in progress while this function is called, this packet is dropped. Once the packet has been sent, the radio switches back to RX mode with the original <a class="el" href="structhw__rx__cfg__t.html" title="The &#39;RX Configuration&#39; for the radio. ">hw_rx_cfg_t</a> settings used (unless either <a class="el" href="group__radio.html#gac4a7a12a95592bbb1a55532e5ddd9e6f" title="Set the radio in the IDLE mode. ">hw_radio_set_idle()</a> or <a class="el" href="group__radio.html#gaeeb8ffcdd89455429d4d13caf08fb661" title="Set the radio in RX mode. ">hw_radio_set_rx()</a> with different rx parameters) is called while the TX is still in progress.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>A pointer to the start of the packet to be transmitted</td></tr>
    <tr><td class="paramname">tx_callback</td><td>The tx_packet_callback_t function to call whenever a packet has been sent by the radio. Please note that this function is called from an <em>interrupt</em> context and therefore can only do minimal processing. If this parameter is 0x0, no callback will be made.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error_t SUCCESS if the packet transmission has been successfully initiated. EINVAL if the tx_cfg parameter contains invalid settings EBUSY if another TX operation is already in progress ESIZE if the packet is either too long or too small EOFF if the radio has not yet been initialised </dd></dl>

</div>
</div>
<a class="anchor" id="gac4a7a12a95592bbb1a55532e5ddd9e6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> hw_radio_set_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the radio in the IDLE mode. </p>
<p>When the radio is IDLE, the tranceiver is disabled to reduce energy consumption. While in this state, it is not possible to receive any packets. The tranceiver can be re-enabled by a call to <a class="el" href="group__radio.html#gaeeb8ffcdd89455429d4d13caf08fb661" title="Set the radio in RX mode. ">hw_radio_set_rx()</a>.</p>
<p>It should be noted that although packet reception is not possible while in IDLE mode, it is possible to transmit packets (by calling hw_radio_send_packet). In that case the radio will go directly from IDLE to TX mode to transmit the packet and then go back to IDLE mode once the packet has been sent.</p>
<p>If the radio is placed in IDLE mode while a packet is being transmitted, the transmisison is completed before the radio is placed in IDLE mode. If the radio is placed in IDLE mode while a packet is being received, the reception of the current packet is interrupted and the radio is placed in IDLE mode IMMEDIATELY.</p>
<dl class="section return"><dt>Returns</dt><dd>error_t SUCCESS if the radio was put in IDLE mode (or will be after the current TX has finished) EALREADY if the radio was already in IDLE mode EOFF if the radio is not yet initialised. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeeb8ffcdd89455429d4d13caf08fb661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> <a class="el" href="types_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> hw_radio_set_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhw__rx__cfg__t.html">hw_rx_cfg_t</a> const *&#160;</td>
          <td class="paramname"><em>rx_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__radio.html#gaf118d5fc80084fae379668fd97f9719b">rx_packet_callback_t</a>&#160;</td>
          <td class="paramname"><em>rx_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__radio.html#ga0ba48debc5245ec6150ac6eb1db19766">rssi_valid_callback_t</a>&#160;</td>
          <td class="paramname"><em>rssi_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the radio in RX mode. </p>
<p>When the radio is placed in RX mode, the tranceiver is configured according to the settings in the supplied <a class="el" href="structhw__rx__cfg__t.html" title="The &#39;RX Configuration&#39; for the radio. ">hw_rx_cfg_t</a> struct after which it starts scanning the channel for possible packets. The radio will stay in RX mode until explicitly set in idle or TX mode.</p>
<p>If the radio is already in RX mode when this function is called, any current packet receptions are interrupted, the new settings are applied and the radio restarts the channel scanning process.</p>
<p>If the radio is in TX mode when this function is called, the current packet transmission is completed before the radio is placed in RX mode.</p>
<p>The user can also supply an rx_packet_callback_t and rssi_valid_callback_t function to the hw_radio_set_rx function.</p>
<p>If the supplied rssi_valid_callback_t function is not 0x0, this function is called once the RSSI value becomes valid.</p>
<p>If the supplied rx_packet_callback_t function is not 0x0, this function is value is called whenever a packet is received from the radio. See the note for rx_packet_callback_t for more information about the allocation/deallocation of packet buffers wrt. packets passed on to this function. If the supplied rx_packet_callback_t function is 0x0, the radio enters RX mode (and will be able to to RSSI measurements) but any received packets are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx_cfg</td><td>A pointer to the rx settings to apply before entering RX mode.</td></tr>
    <tr><td class="paramname">rx_callback</td><td>The rx_packet_callback_t function to call whenever a packet is received please note that this function is called from an <em>interrupt</em> context and therefore can only do minimal processing. If this function is 0x0, all received packets will be dropped.</td></tr>
    <tr><td class="paramname">rssi_callback</td><td>The rssi_valid_callback_t function to call whenever the RSSI value becomes valid after the radio enters RX mode. Please note that this function is called from an <em>interrupt</em> context and therefore can only do minimal processing. Also not that this function can be called (depending on the radio chip) before the call to <a class="el" href="group__radio.html#gaeeb8ffcdd89455429d4d13caf08fb661" title="Set the radio in RX mode. ">hw_radio_set_rx()</a> itself returns. If this function is 0x0, no callback will be made when the RSSI becomes valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error_t SUCCESS if the radio was put in RX mode (or will be after the current TX has finished) EINVAL if the supplied rx_cfg contains invalid parameters. EOFF if the radio is not yet initialised. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc4c71396001bf829c2527e944637a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="link__c_8h.html#ad7a35fa85166c1d1839000ac10353068">__LINK_C</a> bool hw_radio_tx_busy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether or not the radio is currently transmitting a packet. </p>
<dl class="section return"><dt>Returns</dt><dd>bool true if the radio is currently transmitting a packet, false if it is not. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Aug 27 2015 08:44:08 for OSS-7: Open Source Stack for DASH7 Alliance Protocol by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
