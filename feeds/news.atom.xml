<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>OSS-7 - News</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/" rel="alternate"></link><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/feeds/news.atom.xml" rel="self"></link><id>http://mosaic-lopow.github.io/dash7-ap-open-source-stack/</id><updated>2015-07-06T12:00:00+02:00</updated><entry><title>Smartphone DASH7 and NFC communication using an NFC antenna</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/smartphone-dash7-and-nfc-communication-using-an-nfc-antenna.html" rel="alternate"></link><published>2015-07-06T12:00:00+02:00</published><updated>2015-07-06T12:00:00+02:00</updated><author><name>Glenn Ergeerts</name></author><id>tag:mosaic-lopow.github.io,2015-07-06:/dash7-ap-open-source-stack/smartphone-dash7-and-nfc-communication-using-an-nfc-antenna.html</id><summary type="html">&lt;p&gt;In this post we explain a proof of concept which demonstrate that DASH7 can be integrated into a smarthpone, by making use of an NFC antenna, and thus in a space efficient way.&lt;/p&gt;</summary><content type="html">&lt;p&gt;While smartphones already contain a myriad of communication technologies we thought it would be great to add DASH7 to this list.
Adding DASH7 support to a smartphone allows to interact with wireless sensors at a larger range compared to for example BLE.
However, since smarthpones are very space constrained the challenge is how to integrate the antenna for 433 or 868 MHz.
For this reason, we decided to explore the feasibility of reusing an NFC antenna (which is already present in more and more smartphones) for the DASH7 communication as well. &lt;/p&gt;
&lt;p&gt;The video below shows the use case where we have temperature sensor which transmits it's temperature reading over DASH7, which in turn will be received on and displayed by the smartphone. To show NFC is still working we first read an NFC tag containing the sensor's ID, which actives the reception in the smartphone app. The sensor is an &lt;a href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/doxygen/md_hardware.html"&gt;STK3700&lt;/a&gt; running the stk3700_sensor application which is part of OSS-7.&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/rh8vZhYMgog" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;For this demo we used an off the shelf Sansung S4 smartphone. We attached an external antenna board to the NFC antenna connection pads.
On the antenna board we have (besides the antenna itself) a diplexer circuit we designed which allows to use the antenna for both technologies by shielding them from each other and providing the correct matching. Attached to the antenna board is the NFC chip inside the smartphone on the one hand and a Wizzimote/CC430 SoC (the white board on the picture) which runs the OSS-7 stack. To be able to communicate between the OSS-7 stack and the smartphone we are using an UART to USB converter, which is the red board on the picture.&lt;/p&gt;
&lt;p&gt;&lt;img alt="DLT" src="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/images/IMG_20150703_161123.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The results are very promising. It certainly is possible to use a combined antenna for NFC and DASH7. Because of this the biggest technical hurdle to integrating DASH7 into the space constrained smartphone is removed. What remains are a few passive components and an RF chip, which can be miniaturized easily.
Currently we are using an external NFC antenna because this is easier to integrate. In the future we will look into using the internal antenna (which is located in the battery in this model) and improve the diplexer further.&lt;/p&gt;
&lt;p&gt;Many thanks to Jens Vanhooydonck, who implemented this as part of his master thesis!&lt;/p&gt;</content><category term="Hardware"></category><category term="Demo"></category></entry><entry><title>Checkout our new RF modules for the Giant Gecko</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/checkout-our-new-rf-modules-for-the-giant-gecko.html" rel="alternate"></link><published>2015-06-03T17:00:00+02:00</published><updated>2015-06-03T17:00:00+02:00</updated><author><name>Dragan Subotic</name></author><id>tag:mosaic-lopow.github.io,2015-06-03:/dash7-ap-open-source-stack/checkout-our-new-rf-modules-for-the-giant-gecko.html</id><summary type="html">&lt;p&gt;After a long time developing on the CC430, we are switching to a more powerful microcontroller. The CC430 is a 16 bit microcontroller and now the shift is made to a 32 bit cortex M3 from Silicon Labs. The development board that we are using is the Giant Gecko STK-3700. The CC430 is an SoC that contains a microcontroller and radio chip. The Giant Gecko is only a microcontroller and therefore we had to develop a radio module which can be plugged-in the expansion port of the Gecko starter kit.&lt;/p&gt;</summary><content type="html">&lt;p&gt;After a long time developing on the CC430, we are switching to a more powerful microcontroller. The CC430 is a 16 bit microcontroller and now the shift is made to a 32 bit cortex M3 from Silicon Labs. The development board that we are using is the &lt;a href="https://www.silabs.com/products/mcu/lowpower/Pages/efm32gg-stk3700.aspx"&gt;Giant Gecko STK-3700&lt;/a&gt;. The CC430 is an SoC that contains a microcontroller and radio chip. The Giant Gecko is only a microcontroller and therefore we had to develop a radio module which can be plugged-in the expansion port of the Gecko starter kit.&lt;/p&gt;
&lt;p&gt;Because the expertise that is build up around CC1101, the choice is made to develop first a CC1101 RF module. Later on, different RF chips will be included in the platform, but now we are focusing on the CC1101 and the Giant Gecko.&lt;/p&gt;
&lt;p&gt;The Gaint Gecko is a development board that contains onboard programmer from Segger. There are few sensors on board that can be easily used with the DASH7 open software stack. There are four sensors: temperature, light sensor, metal detection and capacitive touch sensor. An LCD make it possible to show the sensor data on the screen, but also other data as received signal strength. A very nice feature that silicon lab provides is the Simplicity Studio software package. It not only contains a prepared IDE based on Eclipse, but also low-power measurement software to measure the impact of different parts of the code on the energy consumption.  &lt;/p&gt;
&lt;p&gt;Other important features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two userbuttons&lt;/li&gt;
&lt;li&gt;Two LEDs&lt;/li&gt;
&lt;li&gt;CR2032 connector, other solution is to power the board with a USB connector&lt;/li&gt;
&lt;li&gt;All pins are accessible with a jumper cable&lt;/li&gt;
&lt;li&gt;USB on-the-go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The RF module is based on the basic schematic from the TI CC1101 development kit. Only this board provide a connector that smoothly fits on the Gaint Gecko. Currently  two frequencies are supported, 433MHz and 868 MHz. 
The &lt;a href="https://www.silabs.com/products/mcu/lowpower/Pages/efm32gg-stk3700.aspx"&gt;Giant Gecko STK-3700&lt;/a&gt; is available on different online electronic component shops. Such as Farnell, Mouser, Digikey, etc.
More information about this module and the schema itself is available on our &lt;a href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/doxygen/md_hardware.html"&gt;supported hardware page&lt;/a&gt; If you have questions about the RF module you can contact use through mailing list or Github.&lt;/p&gt;
&lt;p&gt;&lt;img alt="DLT" src="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/images/GG_CC1101.jpg"&gt;&lt;/p&gt;</content><category term="Hardware"></category></entry><entry><title>DASH7 Alliance Protocol v1.0</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/dash7-alliance-protocol-v10.html" rel="alternate"></link><published>2015-05-04T12:00:00+02:00</published><updated>2015-05-04T12:00:00+02:00</updated><author><name>Glenn Ergeerts</name></author><id>tag:mosaic-lopow.github.io,2015-05-04:/dash7-ap-open-source-stack/dash7-alliance-protocol-v10.html</id><summary type="html">&lt;p&gt;Version 1.0 of the DASH7 Alliance Protocol has been voted by the alliance members during the Spring Meeting in Berlin last week. In this post we will shed some light on the current status and planning of v1.0 support in OSS-7.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Version 1.0 is a very important release for the DASH7 Alliance and concludes 18 months of hard work by the Protocol Action Group. Compared to the draft v0.2 of the spec a lot of things have been changed in the spec. The fact that we now have a voted spec is very important for OSS-7 as well. While we have been trying to incorporate changes during these past 18 months we were tracking a moving target (in the draft branch). With the final release of the spec we now have clear goal.&lt;/p&gt;
&lt;p&gt;During this period we also took the opportunity to redesign the architecture of the underlying OSS-7 framework. We now have a generic framework which has a low-power scheduler, better support for different hardware configurations (MCUs, radio chips, ...) and a flexible buildsystem.
We keep all the documentation (including more high level documentation as opposed to pure API docs) in our &lt;a href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/doxygen"&gt;doxygen site&lt;/a&gt; now, so make sure to check this.&lt;/p&gt;
&lt;p&gt;On top of this architecture we are implementing the stack. We are currently focussing on a EFM32 Giant Gecko MCU and a TI CC1101 radio module. At this moment we have the main drivers for the MCU working and a PHY driver for the CC1101 as well. We have started building the rest of the stack on top of this new framework, starting with the DLL. To be sure we follow the v1.0 spec (instead of an in between draft) we will implement the upper layers manually, only copying code for the draft branch if we are sure this is still valid for v1.0. We realize this is currently a step back in number of layers implemented compared to the draft branch. However, this ensures we are complying to the specification and we are confident implementing the upper layers on top of this more clarified specification and framework will go smooth. Our plan is to implement some typical use cases vertically thoughout all the layers (up untill the application layer) first, instead of implementing all features layer per layer first. This has the advantage we can release examples using the full stack quicker, but has the disadvantage that not all features (like for example encryption) will be postponed for later. &lt;/p&gt;
&lt;p&gt;I merged all branches back to master today, and development will continue on master from now on.&lt;/p&gt;
&lt;p&gt;This blog has been quiet for a long time, but this should change now as well, so keep tuned.&lt;/p&gt;</content><category term="D7AP"></category><category term="General"></category></entry><entry><title>Live capturing of DASH7 traffic in wireshark</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/live-capturing-of-dash7-traffic-in-wireshark.html" rel="alternate"></link><published>2014-08-28T12:00:00+02:00</published><updated>2014-08-28T12:00:00+02:00</updated><author><name>Glenn Ergeerts</name></author><id>tag:mosaic-lopow.github.io,2014-08-28:/dash7-ap-open-source-stack/live-capturing-of-dash7-traffic-in-wireshark.html</id><summary type="html">&lt;p&gt;This post explains how to configure wireshark so it can be used capture live DASH7 traffic using a OSS-7 powered node.&lt;/p&gt;</summary><content type="html">&lt;p&gt;As promised in the &lt;a href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/how-to-analyze-dash7-traffic-in-wireshark.html"&gt;previous post&lt;/a&gt; we will show how to do live capturing in wireshark instead of reading from a previous captured file. Instead of dumping the PCAP data to a regular file the logger writes the data to a named pipe and wireshark reads from this named pipe. As a prerequisite, make sure the setup of the &lt;a href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/how-to-analyze-dash7-traffic-in-wireshark.html"&gt;previous post&lt;/a&gt; is functional, since we will be building on top of this. &lt;/p&gt;
&lt;p&gt;When the d7-oss-logger.py script is started with the &lt;code&gt;-p&lt;/code&gt; parameter it will dump the received traffic to a named pipe. The filename of this named pipe depends on the OS you are running, for POSIX systems this is &lt;code&gt;/tmp/oss7-pipe&lt;/code&gt;, for MS Windows this is &lt;code&gt;\\.\pipe\oss7-pipe&lt;/code&gt;.
The logger will create the named pipe and wait for a client connection (by wireshark in our case) before it writes data to it.
When wireshark conencts the logger will first transmit the PCAP header, followed by the subsequent frames which are received.
It is possible to stop listening in wireshark and reconnect later.&lt;/p&gt;
&lt;p&gt;Now, how to configure wireshark to use this named pipe? We add the named pipe 'interface' by choosing &lt;code&gt;Capture &amp;gt; Options ... &amp;gt; Manage Interfaces &amp;gt; New&lt;/code&gt; and filling in the pipe filename mentioned above in the &lt;code&gt;Pipe&lt;/code&gt; field. The named pipe should appear in the interface list, and you can now start listening on it.&lt;/p&gt;
&lt;p&gt;One caveat to keep in mind is that when you quit the logger while capturing in wireshark you will need to restart the capture in wireshark again after restarting the logger. 
Being able to start the logger from within wiresharj would make the integration easier, but this is not possible in wireshark currently. However, there is a &lt;a href="http://sharkfest.wireshark.org/sharkfest.13/presentations/NAP-11_Expanding-Wireshark-Beyond-Ethernet-and-Network-Interfaces_Kershaw-Ryan.pdf"&gt;proposal&lt;/a&gt; which might enable this in the future.&lt;/p&gt;
&lt;p&gt;Happy capturing!&lt;/p&gt;</content><category term="Tools"></category></entry><entry><title>How to analyze DASH7 traffic in wireshark</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/how-to-analyze-dash7-traffic-in-wireshark.html" rel="alternate"></link><published>2014-08-13T16:00:00+02:00</published><updated>2014-08-13T16:00:00+02:00</updated><author><name>Glenn Ergeerts</name></author><id>tag:mosaic-lopow.github.io,2014-08-13:/dash7-ap-open-source-stack/how-to-analyze-dash7-traffic-in-wireshark.html</id><summary type="html">&lt;p&gt;This post explains how to configure wireshark so it can be used to analyze DASH7 traffic captured using a OSS-7 powered node.&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post we assume you already have a OSS-7 powered node running and are able to get the log information using the tools/PyLogger/d7-oss-logger.py script. The OSS-7 stack running on the node needs to be built with LOG_PHY_ENABLED defined, in order to receive the raw packet data.&lt;/p&gt;
&lt;p&gt;When the d7-oss-logger.py script is started with the &lt;code&gt;-f [file]&lt;/code&gt; parameter it will dump the received traffic to the specified file in the PCAP format (the file format used by wireshark).&lt;/p&gt;
&lt;p&gt;Next we need to configure wireshark to correctly dissect this file. Since wireshark obviously does not know about the OSS-7 and DASH7 packet structure we will need to add a dissector plugin which adds support for parsing the DASH7 packets.
This plugin is provided in the form of a lua script and can be found in the OSS-7 repository in the &lt;code&gt;tools/wireshark-dissector/&lt;/code&gt; directory. Next we need to tell wireshark to use this script. This can be done by calling the script from the init.lua script by adding the following line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;dofile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;PATH-TO-OSS7&amp;gt;/tools/wireshark-dissector/oss7-wireshark-dissector.lua&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The init.lua script can found in &lt;code&gt;$HOME/.wireshark/init.lua&lt;/code&gt; on linux or &lt;code&gt;C:\Program Files\Wireshark&lt;/code&gt; on Windows.&lt;/p&gt;
&lt;p&gt;As a final step we need to configure wireshark to use this dissector. This is done by coupling the User 0 link layer type (which the logger uses to write the PCAP file) to the protocol dissector for DASH7. 
To do this select &lt;code&gt;Edit &amp;gt; Preferences &amp;gt; Protocols &amp;gt; DLT_USER &amp;gt; Edit &amp;gt; New&lt;/code&gt;. 
Fill in the dialog like in the screenshot below and press OK.
&lt;img alt="DLT" src="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/images/dlt.png"&gt;&lt;/p&gt;
&lt;p&gt;Now you should be able to analyze DASH7 packets by loading a PCAP file captured with the logger tool. This is shown in the screenshot below.
&lt;img alt="wireshark dissector" src="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/images/wireshark-dissector.png"&gt;&lt;/p&gt;
&lt;p&gt;The dissector does not yet support the full protocol however. This will be implemented in parallel with the stack itself.
As long as you use the same git revision for the stack and for the dissector script you should be fine.&lt;/p&gt;
&lt;p&gt;In a future post we will explain how to go one step further and do live tracing of packets in wireshark instead of reading from a previously captured file.&lt;/p&gt;</content><category term="Tools"></category></entry><entry><title>Welcome to our new site!</title><link href="http://mosaic-lopow.github.io/dash7-ap-open-source-stack/welcome-to-our-new-site.html" rel="alternate"></link><published>2014-06-17T16:00:00+02:00</published><updated>2014-06-17T16:00:00+02:00</updated><author><name>Glenn Ergeerts</name></author><id>tag:mosaic-lopow.github.io,2014-06-17:/dash7-ap-open-source-stack/welcome-to-our-new-site.html</id><summary type="html">&lt;p&gt;On this site you will find all information to get started with OSS-7!&lt;/p&gt;</summary><content type="html"></content><category term="General"></category></entry></feed>